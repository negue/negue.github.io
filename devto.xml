<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Negue's Blog to DevTo RSS]]></title><description><![CDATA[A blog about various tech-topics.]]></description><link>https://negue.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Thu, 11 Jun 2020 20:26:24 GMT</lastBuildDate><item><title><![CDATA[Senstate - Updates, C#-Client and a future look]]></title><description><![CDATA[Example Senstate Gif  Demo Finally after some months I worked a bit on Senstate again. I had some features already "done", but only some…]]></description><link>https://negue.github.io/2020/senstate-updates-and-more/</link><guid isPermaLink="false">https://negue.github.io/2020/senstate-updates-and-more/</guid><pubDate>Thu, 11 Jun 2020 00:00:00 GMT</pubDate><category><![CDATA[[javascript,angular,csharp,senstate]]]></category><content:encoded><![CDATA[
[![Example Senstate Gif](https://thepracticaldev.s3.amazonaws.com/i/zmtm5zab2vlu51qnnnda.gif) <br/> Demo](https://senstate-dashboard-master.netlify.app/#/)


Finally after some months I worked a bit on Senstate again. I had some features already "done", but only some days ago I merged the PR. :smile:

# :confetti_ball: Senstate v0.3 :tada:

New features:
- Group Watchers

  ![group_feature](https://user-images.githubusercontent.com/842273/84432637-610d7880-ac2d-11ea-8cd1-cefa4177b9c8.PNG)

- List Watchers (instead of a masonry-grid, still need some more stying, ideas? thoughts?)
- You can add "difference"-View to see the change of the previous value

  ![example of the difference feature](https://user-images.githubusercontent.com/842273/84432324-f65c3d00-ac2c-11ea-9dc6-f84a4328e5d3.png)

- Errors can be searched on multiple sites, opens a new tab:
  - DuckDuckGo
  - Github
  - Google
  - StackOverflow
  
Also see [CHANGELOG.md](https://github.com/senstate/platform/blob/master/CHANGELOG.md)

# :construction: Whats next?

## In-Web-App-Overlay
Began working on an overlay to use inside your Web-App.

This will be done with Angular Elements (which can be used even without Angular).

Only the "target" connection will be changed (instead of the Hub-Connection), everything else will stay the same.

Repo / wip-changes will be pushed soon

## Now finally working on the C# client:

My goal is to create a library that could be used with, initial tests worked with:
- .Net Standard (I hope this would be all possible targets?)
- Unity
- Blazor Server / WebAssembly

The Library(ies) will be splitted into:
- The main logic, watchers/logger
- separated WebSockets implementation
- separated Json implementation

So that way every possible Target / Platform can have their own Json/WebSocket implementation.

[Repo](https://github.com/senstate/csharp-client) 

I'll post an article on how to use it, once the first version  is published

## Misc

- Try if react-native "just" works ?
- Save Dashboard settings to localStorage
- Extend the Dashboard (all the time, suggestions welcomed)
- Add instructions to the Dashboard itself (if no app is connected) - maybe just show the markdown-file of the client-library? - ideas?
- Creating an example repo for all possible libraries / targets
- Bug fixes

# Feedback

If there are any ideas / feature requests / issues / use-cases, please tell me :)

]]></content:encoded></item><item><title><![CDATA[Working with graph structures]]></title><description><![CDATA[Preamble: I'm not that experienced in graph-theory or like getting the shortest path to a node. :) This article is rather a short…]]></description><link>https://negue.github.io/2020/graph-data-structure/</link><guid isPermaLink="false">https://negue.github.io/2020/graph-data-structure/</guid><pubDate>Mon, 18 May 2020 00:00:00 GMT</pubDate><category><![CDATA[[javascript,graph,gundb,datastructure]]]></category><content:encoded><![CDATA[
> Preamble: I'm not that experienced in graph-theory or like getting the shortest path to a node. :) This article is rather a short introduction into "How to re-create your usual list-states into a graph/object structure - in addition: with some examples using [GunDB/GunJS][gunDbLink]" 

## What is GunDB/GunJS ?

Its an offline-first, distributed, p2p synced graph-database created by [Mark Nadal][amark]. You can also create accounts (offline) and encrypt data nodes. Enough buzzwords but also true. More info's at the [repo][gunDbLink].

## Example of working with the API and simple data 

```js
const gun = Gun();

gun.get('node').put({
  someString: "Mark",
  someNumber: 42,
});

gun.get('othernode').get('sub').put({
  // ...some other props
});
// sets the data in put, to the node "othernode.sub"
```

You have the following api's:
- `.get('YOUR_NODE')` - just says "go to the node of YOUR_NODE" , and all other operations will be done from this one 
  > note: this does not get the actual value
- `.put()` - sets the data in the current node-context
- `.once(callback)` - gets the data `once`
- there are also other callback types which get the updates all the time - or like normal promises using `.then`
  > [see Docs][docsUrl]

## Working with lists in a object/graph-world

Gun can't really work with lists, due to the syncing between peers is based on properties. 

> This part can be theoretically also used with any redux-like state outside of gun.

Your usual lists look (probably) this:

```js
const myList = [ 
  {
    id: 'someId',
    data: 'string'
  },
  {
    id: 'otherId',
    data: 'other string' // or object
  },
]
```

If you want to move an item in your list or edit this item, you'd either:
- create a new array, which has the items order / new value
- or move item A to new pos X, and the re-set all other affected items to their new pos
- maybe some other way I forgot

A better graph-way would be something like this:

```js
const state = { 
  "yourlist": {
    "nodes": {
      "someId": {
                    id: 'someId',
                    data: 'string'
                },  // or just use the data, if you want to optimize
      "otherId": {
                     id: 'otherId',
                     data: 'other string'
                   },
    },
    "order": {
      "someId": 1,
      "otherId": 2,
    }
  }
}
```

At first glance it looks like a lot of unneeded / redundant stuff right?

But you probably ask yourself, "what If I just set the whole `yourlist`-node, wouldn't that just work?" - Yes, if you just subscribe only to this one node, you don't need any optimization. Then you could just add the order property to node. 

With this type of state:
- you only have 2 operations when switching a position of two items
- you only have 1 operation when changing the data of a node

> Note: Less operations, means less data to sync => faster

I choose this structure, because I had encrypted data nodes and when the whole list changed, I had to de-crypt all nodes on each new callback - which is wasted CPU / Page performance. But with that optimized structure, I could handle this much easier, without having to use something like an "object-differ":
- Subscription: "the order changed" => just move item to different place
- Subscription: "the data changed" => load the newest update -> decrypt -> show it

Sure, this still is not the "perfect" solution, for example: When you have 100 items, and you want to move Item 44 to 55, you'd have to do 12 operations.

If you want to optimize this even further, you could implement a linked list, with this you could even decrease the number operations, to about 3.

> Note: It all depends on the amount of your data.

But how to get the correct order again?

```js
const {nodes, order} = state.yourlist;

const orderedList = Object.values(nodes)
      .sort((a, b) => order[a.id] - order[b.id]);
```

## Working with lists in a GunDB-World

```js
const gun = Gun();

// Saving data
const graphNode = gun.get('your_list');
const nodes = graphNode.get('nodes');
const order = graphNode.get('order');

nodes.get('someId')
      .put({
        id: 'someId',
        data: 'string'
      });

nodes.get('otherId')
      .put({
        id: 'otherId',
        data: 'other string'
      });

order.get('someId')
     .put(1);

order.get('otherId')
     .put(2);

// react on changed data (or reading from gun) 
graphNode.on((listData) => {
  const {nodes, order} = listData;
  
  const orderedList = Object.values(nodes)
        .sort((a, b) => order[a.id] - order[b.id]);

  // work with the list, send it to your views etc
});

```

I hope this was an "easy"-ish intro to list-handling with GunDB and or object-only states, if not please write me on how it could be made better?

[amark]: https://github.com/amark
[gunDbLink]: https://github.com/amark/gun
[docsUrl]: https://github.com/amark/gun/wiki/API
]]></content:encoded></item></channel></rss>